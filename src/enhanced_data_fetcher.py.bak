"""
Enhanced data fetcher with yfinance and ccxt support.
Provides unified interface for both crypto and traditional markets.
"""

import ccxt
import yfinance as yf
import pandas as pd
from datetime import datetime, timedelta
import logging
from typing import Literal

logger = logging.getLogger(__name__)

DataSource = Literal['crypto', 'stock', 'auto']
TimeFrame = Literal['1m', '5m', '15m', '30m', '1h', '4h', '1d', '1w', '1M']

TIMEFRAME_TO_YFINANCE = {
    '1m': '1m',
    '5m': '5m',
    '15m': '15m',
    '30m': '30m',
    '1h': '60m',
    '4h': '1d',  # yfinance doesn't support 4h, use 1d
    '1d': '1d',
    '1w': '1wk',
    '1M': '1mo'
}

TIMEFRAME_TO_DAYS = {
    '1m': 7,      # Max 7 days for minute data in yfinance
    '5m': 60,     # Max 60 days for 5m data
    '15m': 60,
    '30m': 60,
    '1h': 730,    # Max 730 days for hourly
    '4h': 730,
    '1d': 5000,   # Many years of daily data
    '1w': 5000,
    '1M': 5000
}

class UnifiedDataFetcher:
    """Unified data fetcher for crypto and traditional markets."""
    
    def __init__(self):
        self.crypto_exchanges = {
            'binance': ccxt.binance,
            'coinbase': ccxt.coinbase,
            'kraken': ccxt.kraken,
            'kucoin': ccxt.kucoin,
            'bybit': ccxt.bybit,
        }
    
    def fetch_data(
        self,
        symbol: str,
        timeframe: TimeFrame = '1d',
        limit: int = 500,
        source: DataSource = 'auto',
        exchange: str | None = None
    ) -> pd.DataFrame | None:
        """
        Fetch data from either crypto exchanges or traditional markets.
        
        Args:
            symbol: Trading symbol (e.g., 'BTC/USDT' for crypto, 'AAPL' for stocks)
            timeframe: Time interval for candles
            limit: Number of data points to fetch
            source: Data source type ('crypto', 'stock', 'auto')
            exchange: Specific exchange for crypto (optional)
        
        Returns:
            DataFrame with OHLCV data or None if failed
        """
        if source == 'auto':
            # Try to determine source based on symbol format
            if '/' in symbol or symbol.endswith('USDT') or symbol.endswith('USD'):
                source = 'crypto'
            else:
                source = 'stock'
        
        if source == 'crypto':
            return self._fetch_crypto(symbol, timeframe, limit, exchange)
        else:
            return self._fetch_stock(symbol, timeframe, limit)
    
    def _fetch_crypto(
        self,
        symbol: str,
        timeframe: TimeFrame,
        limit: int,
        exchange: str | None
    ) -> pd.DataFrame | None:
        """Fetch cryptocurrency data using ccxt."""
        exchanges_to_try = [exchange] if exchange else list(self.crypto_exchanges.keys())
        
        for ex_name in exchanges_to_try:
            if ex_name not in self.crypto_exchanges:
                continue
                
            try:
                exchange_class = self.crypto_exchanges[ex_name]
                exchange_obj = exchange_class()
                
                # Fetch OHLCV data
                ohlcv = exchange_obj.fetch_ohlcv(symbol, timeframe, limit=limit)
                
                if not ohlcv:
                    continue
                
                df = pd.DataFrame(
                    ohlcv,
                    columns=['timestamp', 'open', 'high', 'low', 'close', 'volume']
                )
                df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
                df['source'] = 'crypto'
                df['exchange'] = ex_name
                df['symbol'] = symbol
                df['timeframe'] = timeframe
                
                logger.info(f"Successfully fetched {len(df)} records for {symbol} from {ex_name}")
                return df
                
            except Exception as e:
                logger.warning(f"Failed to fetch {symbol} from {ex_name}: {e}")
                continue
        
        logger.error(f"Failed to fetch {symbol} from all crypto exchanges")
        return None
    
    def _fetch_stock(
        self,
        symbol: str,
        timeframe: TimeFrame,
        limit: int
    ) -> pd.DataFrame | None:
        """Fetch stock/ETF data using yfinance."""
        try:
            # Convert timeframe to yfinance format
            yf_interval = TIMEFRAME_TO_YFINANCE.get(timeframe, '1d')
            
            # Calculate period based on limit and timeframe
            max_days = TIMEFRAME_TO_DAYS.get(timeframe, 730)
            
            # Estimate days needed based on limit
            if timeframe in ['1m', '5m', '15m', '30m']:
                # Intraday data
                trading_hours_per_day = 6.5  # Regular trading hours
                if timeframe == '1m':
                    candles_per_day = 390
                elif timeframe == '5m':
                    candles_per_day = 78
                elif timeframe == '15m':
                    candles_per_day = 26
                else:  # 30m
                    candles_per_day = 13
                days_needed = min(int(limit / candles_per_day) + 2, max_days)
            elif timeframe == '1h':
                candles_per_day = 24  # For extended hours
                days_needed = min(int(limit / candles_per_day) + 2, max_days)
            elif timeframe == '1w':
                days_needed = min(limit * 7 + 14, max_days)
            elif timeframe == '1M':
                days_needed = min(limit * 30 + 60, max_days)
            else:  # Daily
                days_needed = min(limit + 10, max_days)
            
            # Create ticker object
            ticker = yf.Ticker(symbol)
            
            # Calculate start date
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days_needed)
            
            # Fetch data
            df = ticker.history(
                start=start_date,
                end=end_date,
                interval=yf_interval
            )
            
            if df.empty:
                logger.error(f"No data returned for {symbol} from yfinance")
                return None
            
            # Rename columns to match our format
            df = df.reset_index()
            df.columns = df.columns.str.lower()
            
            # Ensure we have the required columns
            if 'date' in df.columns:
                df.rename(columns={'date': 'timestamp'}, inplace=True)
            elif 'datetime' in df.columns:
                df.rename(columns={'datetime': 'timestamp'}, inplace=True)
            
            # Add metadata
            df['source'] = 'stock'
            df['exchange'] = 'yfinance'
            df['symbol'] = symbol
            df['timeframe'] = timeframe
            
            # Limit to requested number of rows
            if len(df) > limit:
                df = df.tail(limit)
            
            logger.info(f"Successfully fetched {len(df)} records for {symbol} from yfinance")
            return df
            
        except Exception as e:
            logger.error(f"Failed to fetch {symbol} from yfinance: {e}")
            return None
    
    def fetch_multi_timeframe(
        self,
        symbol: str,
        timeframes: list[TimeFrame],
        limits: dict[TimeFrame, int] | None = None,
        source: DataSource = 'auto'
    ) -> dict[TimeFrame, pd.DataFrame]:
        """
        Fetch data for multiple timeframes.
        
        Args:
            symbol: Trading symbol
            timeframes: List of timeframes to fetch
            limits: Dict mapping timeframe to limit (optional)
            source: Data source type
        
        Returns:
            Dict mapping timeframe to DataFrame
        """
        if limits is None:
            limits = {tf: 500 for tf in timeframes}
        
        results = {}
        for tf in timeframes:
            limit = limits.get(tf, 500)
            df = self.fetch_data(symbol, tf, limit, source)
            if df is not None:
                results[tf] = df
            else:
                logger.warning(f"Failed to fetch data for timeframe {tf}")
        
        return results
